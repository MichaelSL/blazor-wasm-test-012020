@using System.Text.RegularExpressions
@using Blazored.LocalStorage
@using BlazorWasmRegex.Shared.Services
@using BlazorStrap
@using Microsoft.JSInterop
@using System.Text.Json
@inject BlazorWasmRegex.Shared.Interfaces.IRegexService regexService
@inject BlazorWasmRegex.Shared.Interfaces.IHtmlHelperService htmlHelperService
@inject ILocalStorageService LocalStorage
@inject IJSRuntime JS

<p>
    <label>Samples:</label>
    <select class="form-select" @onchange="OnSampleChanged">
        <option value="">-- Select a sample --</option>
        <option value="Email">Email</option>
        <option value="Phone">Phone</option>
        <option value="Url">URL</option>
    </select>
</p>
<p>
    <label>Regex:</label>
    <input class="form-control" @bind="RegexText" />
</p>
<p>
    <label>Options:</label>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" @bind="IgnoreCase" id="ignoreCase">
        <label class="form-check-label" for="ignoreCase">Ignore Case</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" @bind="Multiline" id="multiline">
        <label class="form-check-label" for="multiline">Multiline</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" @bind="Singleline" id="singleline">
        <label class="form-check-label" for="singleline">Singleline</label>
    </div>
</p>
<p>
    <label>Replacement Pattern:</label>
    <input class="form-control" @bind="ReplacementPattern" placeholder="e.g., $1, ${name}, or literal text" />
    <small class="form-text text-muted">Use $1, $2 for numbered groups or ${name} for named groups</small>
</p>
<p>
    <label>Tests:</label>
    <textarea class="form-control" @bind="Tests" rows="10"></textarea>
</p>
<p>
    <div class="hr-flex-container">
        <div>
            <BSButton Color="BSColor.Primary" OnClick="@Test_Click"><span class="oi oi-beaker" aria-hidden="true">&nbsp;</span>Test</BSButton>
            <BSButton Color="BSColor.Success" OnClick="@Replace_Click" Disabled="@string.IsNullOrEmpty(ReplacementPattern)"><span class="oi oi-loop-circular" aria-hidden="true">&nbsp;</span>Replace</BSButton>
            <BSButton Color="BSColor.Secondary" OnClick="@ExportAsJson" Disabled="@(!NotEmptyMatches.Any())"><span class="oi oi-data-transfer-download" aria-hidden="true">&nbsp;</span>JSON</BSButton>
            <BSButton Color="BSColor.Secondary" OnClick="@ExportAsCsv" Disabled="@(!NotEmptyMatches.Any())"><span class="oi oi-data-transfer-download" aria-hidden="true">&nbsp;</span>CSV</BSButton>
            <BSButton Color="BSColor.Secondary" OnClick="@ExportAsText" Disabled="@(!NotEmptyMatches.Any())"><span class="oi oi-data-transfer-download" aria-hidden="true">&nbsp;</span>Text</BSButton>
        </div>
        <div class="space-out">
            <span class="oi oi-terminal" aria-hidden="true">&nbsp;</span>@((MarkupString)Message)
        </div>
    </div>
</p>
<p>
    <BSTabGroup>
        <BSTabList>
            <BSTab>
                <BSTabLabel>Matches</BSTabLabel>
                <BSTabContent>
                    <ul class="list-group">
                        @foreach (var m in MatchedStrings)
                        {
                            <li class="list-group-item">@((MarkupString)m)</li>
                        }
                    </ul>
                </BSTabContent>
            </BSTab>
            <BSTab>
                <BSTabLabel>Split list</BSTabLabel>
                <BSTabContent>
                    <ul class="list-group">
                        @foreach (var m in SplitList)
                        {
                            <li class="list-group-item">@((MarkupString)m)</li>
                        }
                    </ul>
                </BSTabContent>
            </BSTab>
            <BSTab>
                <BSTabLabel>Table</BSTabLabel>
                <BSTabContent>
                    <ul class="list-group">
                        @foreach (var m in NotEmptyMatches)
                        {
                            <li class="list-group-item">
                                <strong>@m.Key</strong>
                            </li>
                            @foreach (Match match in m.Value)
                            {
                                <li class="list-group-item">
                                    <div class="hr-flex-container">
                                        <span class="space-out">
                                            Index: @match.Index
                                        </span>
                                        <span class="space-out">
                                            Length: @match.Length
                                        </span>
                                        <span class="space-out">
                                            Value: @match.Value
                                        </span>
                                    </div>
                                </li>
                            }
                        }
                    </ul>
                </BSTabContent>
            </BSTab>
            <BSTab>
                <BSTabLabel>Capture Groups</BSTabLabel>
                <BSTabContent>
                    @if (CaptureGroupData.Any())
                    {
                        <ul class="list-group">
                            @foreach (var testData in CaptureGroupData)
                            {
                                <li class="list-group-item">
                                    <strong>@testData.TestString</strong>
                                </li>
                                @foreach (var matchData in testData.Matches)
                                {
                                    <li class="list-group-item">
                                        <div style="padding-left: 1rem;">
                                            <strong>Match @matchData.MatchIndex</strong> (Index: @matchData.Index, Length: @matchData.Length)
                                            <ul class="list-group" style="margin-top: 0.5rem;">
                                                @foreach (var group in matchData.Groups)
                                                {
                                                    <li class="list-group-item">
                                                        <div class="hr-flex-container">
                                                            <span class="space-out">
                                                                <strong>@group.Name:</strong>
                                                            </span>
                                                            <span class="space-out">
                                                                "@group.Value"
                                                            </span>
                                                            <span class="space-out">
                                                                (Index: @group.Index, Length: @group.Length)
                                                            </span>
                                                        </div>
                                                    </li>
                                                }
                                            </ul>
                                        </div>
                                    </li>
                                }
                            }
                        </ul>
                    }
                    else
                    {
                        <div class="alert alert-info" role="alert">
                            No capture groups found. Use named groups like <code>(?&lt;name&gt;pattern)</code> or numbered groups <code>(pattern)</code> to see capture details here.
                        </div>
                    }
                </BSTabContent>
            </BSTab>
            <BSTab>
                <BSTabLabel>Replace</BSTabLabel>
                <BSTabContent>
                    @if (ReplacedStrings.Any())
                    {
                        <ul class="list-group">
                            @foreach (var item in ReplacedStrings)
                            {
                                <li class="list-group-item">
                                    <div style="margin-bottom: 0.5rem;">
                                        <strong>Original:</strong> <code>@item.Key</code>
                                    </div>
                                    <div>
                                        <strong>Replaced:</strong> <code>@item.Value</code>
                                    </div>
                                </li>
                            }
                        </ul>
                    }
                    else
                    {
                        <div class="alert alert-info" role="alert">
                            Enter a replacement pattern and click the <strong>Replace</strong> button to see results.
                        </div>
                    }
                </BSTabContent>
            </BSTab>
        </BSTabList>
        <BSTabSelectedContent />
    </BSTabGroup>
</p>

@code {
    const string REGEX_SESSION_STORAGE_KEY = nameof(REGEX_SESSION_STORAGE_KEY);
    const string TESTS_SESSION_STORAGE_KEY = nameof(TESTS_SESSION_STORAGE_KEY);
    private static readonly TimeSpan RegexTimeout = TimeSpan.FromSeconds(2);

    protected string Tests { get; set; }
    protected string RegexText { get; set; }
    protected string SelectedSample { get; set; }
    protected string ReplacementPattern { get; set; }
    protected bool IgnoreCase { get; set; }
    protected bool Multiline { get; set; }
    protected bool Singleline { get; set; }
    protected IEnumerable<string> MatchedStrings { get; set; } = new List<string>();
    protected IEnumerable<string> SplitList { get; set; } = new List<string>();
    protected IEnumerable<KeyValuePair<string, MatchCollection>> NotEmptyMatches { get; set; } = new Dictionary<string, MatchCollection>();
    protected IDictionary<string, string> ReplacedStrings { get; set; } = new Dictionary<string, string>();
    protected List<TestCaptureGroupData> CaptureGroupData { get; set; } = new();
    protected string Message { get; set; }

    private Regex testRegex;
    private (string RegexText, bool IgnoreCase, bool Multiline, bool Singleline)? prevRegexConfig;

    // Data structures for capture groups display
    public class TestCaptureGroupData
    {
        public string TestString { get; set; }
        public List<MatchCaptureGroupData> Matches { get; set; } = new();
    }

    public class MatchCaptureGroupData
    {
        public int MatchIndex { get; set; }
        public int Index { get; set; }
        public int Length { get; set; }
        public List<CaptureGroupInfo> Groups { get; set; } = new();
    }

    public class CaptureGroupInfo
    {
        public string Name { get; set; }
        public string Value { get; set; }
        public int Index { get; set; }
        public int Length { get; set; }
    }

    // Record for storing regex options in JSON format
    public record RegexOptionsData(bool IgnoreCase, bool Multiline, bool Singleline);

    protected override async Task OnInitializedAsync()
    {
        RegexText = await LocalStorage.GetItemAsync<string>(REGEX_SESSION_STORAGE_KEY) ?? string.Empty;
        Tests = await LocalStorage.GetItemAsync<string>(TESTS_SESSION_STORAGE_KEY) ?? string.Empty;
        SelectedSample = string.Empty;
        var savedOptions = await LocalStorage.GetItemAsync<string>("REGEX_OPTIONS");
        if (!string.IsNullOrEmpty(savedOptions))
        {
            // Try to parse as JSON first (new format)
            try
            {
                var options = JsonSerializer.Deserialize<RegexOptionsData>(savedOptions);
                if (options != null)
                {
                    IgnoreCase = options.IgnoreCase;
                    Multiline = options.Multiline;
                    Singleline = options.Singleline;
                }
            }
            catch (JsonException)
            {
                // Fallback for legacy pipe-delimited format: "{RegexText}|{IgnoreCase}|{Multiline}|{Singleline}"
                // Note: RegexText is loaded separately; we only parse the options (last 3 values) here.
                var parts = savedOptions.Split('|');
                if (parts.Length >= 4)
                {
                    bool.TryParse(parts[^3], out var ignoreCase);
                    bool.TryParse(parts[^2], out var multiline);
                    bool.TryParse(parts[^1], out var singleline);
                    IgnoreCase = ignoreCase;
                    Multiline = multiline;
                    Singleline = singleline;
                }
            }
        }
    }

    private async Task OnSampleChanged(ChangeEventArgs e)
    {
        SelectedSample = e?.Value?.ToString() ?? string.Empty;

        var pattern = GetPatternForSample(SelectedSample);
        if (!string.IsNullOrEmpty(pattern))
        {
            RegexText = pattern;
            
            // Auto-populate test data if Tests field is empty
            if (string.IsNullOrWhiteSpace(Tests))
            {
                Tests = GetSampleDataForSample(SelectedSample);
            }
            
            // Force recompile next Test_Click by resetting prev config
            prevRegexConfig = null;
            await Test_Click(null);
        }
    }

    private static readonly Dictionary<string, (string Pattern, string SampleData)> SamplePatterns = new()
    {
        { "Email", (SampleRegexLibrary.EmailPattern, SampleRegexLibrary.EmailSampleData) },
        { "Phone", (SampleRegexLibrary.PhonePattern, SampleRegexLibrary.PhoneSampleData) },
        { "Url", (SampleRegexLibrary.UrlPattern, SampleRegexLibrary.UrlSampleData) }
    };

    private static string GetPatternForSample(string sample)
    {
        if (string.IsNullOrWhiteSpace(sample)) return string.Empty;
        return SamplePatterns.TryGetValue(sample, out var value) ? value.Pattern : string.Empty;
    }

    private static string GetSampleDataForSample(string sample)
    {
        if (string.IsNullOrWhiteSpace(sample)) return string.Empty;
        return SamplePatterns.TryGetValue(sample, out var value) ? value.SampleData : string.Empty;
    }

    protected async Task Test_Click(object e)
    {
        if (string.IsNullOrEmpty(RegexText))
            return;

        var currentOptionsData = new RegexOptionsData(IgnoreCase, Multiline, Singleline);
        var currentOptionsJson = JsonSerializer.Serialize(currentOptionsData);
        // Use a tuple-based comparison for change detection to avoid delimiter issues
        var currentConfig = (RegexText, IgnoreCase, Multiline, Singleline);
        if (prevRegexConfig != currentConfig)
        {
            try
            {
                Console.WriteLine("Changing RegEx");
                var options = RegexOptions.Compiled;
                if (IgnoreCase) options |= RegexOptions.IgnoreCase;
                if (Multiline) options |= RegexOptions.Multiline;
                if (Singleline) options |= RegexOptions.Singleline;
                
                testRegex = new Regex(RegexText, options, RegexTimeout);
                prevRegexConfig = (RegexText, IgnoreCase, Multiline, Singleline);

                await LocalStorage.SetItemAsync(REGEX_SESSION_STORAGE_KEY, RegexText);
                await LocalStorage.SetItemAsync("REGEX_OPTIONS", currentOptionsJson);
            }
            catch (RegexParseException regexParseEx)
            {
                Console.WriteLine($"Failed to parse a RegEx: {regexParseEx.Message}; {regexParseEx.Error}; {regexParseEx.Offset}");
                Message = $"Failed to parse an expression 😒: <b>{regexParseEx.Error}</b> at pos <b>{regexParseEx.Offset}</b>.";
                return;
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Failed to parse a RegEx: <b>{ex.Message}</b>; {ex.GetType().Name}");
                Message = "Failed to parse an expression 😒";
                return;
            }
        }


        try
        {
            var tests = Tests?
                .Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .Distinct();

            var (elapsedMilliseconds, matches) = regexService.GetMatches(tests, testRegex);

            NotEmptyMatches = matches
                .Where(kvp => kvp.Value.Count > 0)
                .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            Message = $"{NotEmptyMatches.Count()} matches in {elapsedMilliseconds} ms";

            // Only show inputs that have matches
            MatchedStrings = matches
                .Where(mc => mc.Value.Count > 0)
                .Select(mc => htmlHelperService.GetMarkedSpans(mc.Key, mc.Value, "mark-yellow"));

            // Only show inputs that have split results (where split actually occurred)
            var splitResults = regexService.GetSplitList(tests, testRegex);
            SplitList = splitResults.Select(m => htmlHelperService.GetDelimeteredString(m, " <span class='oi oi-pin' aria-hidden='true'></span> "));
            
            // Extract capture group data
            CaptureGroupData = ExtractCaptureGroupData(matches);
            
            await LocalStorage.SetItemAsync(TESTS_SESSION_STORAGE_KEY, Tests);
        }
        catch (RegexMatchTimeoutException timeoutEx)
        {
            Console.WriteLine($"RegEx timed out: {timeoutEx.Message}");
            Message = "⏱ Expression timed out - possible catastrophic backtracking";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Something went wrong... {ex.Message}");
            Message = "Error evaluating expression ☠";
        }
    }

    private List<TestCaptureGroupData> ExtractCaptureGroupData(IDictionary<string, MatchCollection> matches)
    {
        var result = new List<TestCaptureGroupData>();

        foreach (var kvp in matches.Where(m => m.Value.Count > 0))
        {
            var testData = new TestCaptureGroupData
            {
                TestString = kvp.Key
            };

            int matchIndex = 0;
            foreach (Match match in kvp.Value)
            {
                var matchData = new MatchCaptureGroupData
                {
                    MatchIndex = matchIndex++,
                    Index = match.Index,
                    Length = match.Length
                };

                // Get group names from the regex
                var groupNames = testRegex.GetGroupNames();

                foreach (var groupName in groupNames)
                {
                    var group = match.Groups[groupName];
                    if (group.Success)
                    {
                        matchData.Groups.Add(new CaptureGroupInfo
                        {
                            Name = groupName,
                            Value = group.Value,
                            Index = group.Index,
                            Length = group.Length
                        });
                    }
                }

                // Only add match data if it has groups (besides the default "0" group)
                if (matchData.Groups.Count > 0)
                {
                    testData.Matches.Add(matchData);
                }
            }

            // Only add test data if it has matches with groups
            if (testData.Matches.Count > 0)
            {
                result.Add(testData);
            }
        }

        return result;
    }

    protected async Task Replace_Click(object e)
    {
        if (string.IsNullOrEmpty(RegexText) || string.IsNullOrEmpty(ReplacementPattern) || testRegex == null)
            return;

        try
        {
            var tests = Tests?
                .Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .Distinct();

            ReplacedStrings = regexService.GetReplacedStrings(tests, testRegex, ReplacementPattern);
            Message = $"Replaced in {ReplacedStrings.Count} test strings";
        }
        catch (RegexMatchTimeoutException timeoutEx)
        {
            Console.WriteLine($"RegEx timed out: {timeoutEx.Message}");
            Message = "⏱ Expression timed out - possible catastrophic backtracking";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Replace error: {ex.Message}");
            Message = "Error during replace operation ☠";
        }
    }

    private async Task ExportAsJson(object e)
    {
        try
        {
            var exportData = NotEmptyMatches.ToDictionary(
                kvp => kvp.Key,
                kvp => kvp.Value.Cast<Match>().Select(m => new
                {
                    Value = m.Value,
                    Index = m.Index,
                    Length = m.Length,
                    Groups = m.Groups.Cast<Group>().Skip(1).Select(g => new
                    {
                        Value = g.Value,
                        Index = g.Index,
                        Length = g.Length
                    }).ToList()
                }).ToList()
            );

            var json = JsonSerializer.Serialize(exportData, new JsonSerializerOptions
            {
                WriteIndented = true
            });

            await JS.InvokeVoidAsync("downloadFile", "matches.json", json, "application/json");
            Message = "✓ Exported matches as JSON";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Export JSON error: {ex.Message}");
            Message = "Error exporting JSON ☠";
        }
    }

    private async Task ExportAsCsv(object e)
    {
        try
        {
            var csv = new System.Text.StringBuilder();
            csv.AppendLine("Test String,Match Value,Match Index,Match Length");

            foreach (var kvp in NotEmptyMatches)
            {
                foreach (Match match in kvp.Value)
                {
                    csv.AppendLine($"\"{EscapeCsv(kvp.Key)}\",\"{EscapeCsv(match.Value)}\",{match.Index},{match.Length}");
                }
            }

            await JS.InvokeVoidAsync("downloadFile", "matches.csv", csv.ToString(), "text/csv");
            Message = "✓ Exported matches as CSV";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Export CSV error: {ex.Message}");
            Message = "Error exporting CSV ☠";
        }
    }

    private async Task ExportAsText(object e)
    {
        try
        {
            var text = new System.Text.StringBuilder();
            text.AppendLine($"Regex Pattern: {RegexText}");
            text.AppendLine($"Total Matches: {NotEmptyMatches.Sum(kvp => kvp.Value.Count())}");
            text.AppendLine($"Test Strings with Matches: {NotEmptyMatches.Count()}");
            text.AppendLine();

            foreach (var kvp in NotEmptyMatches)
            {
                text.AppendLine($"Test String: {kvp.Key}");
                text.AppendLine($"Matches ({kvp.Value.Count}):");
                
                foreach (Match match in kvp.Value)
                {
                    text.AppendLine($"  - Value: \"{match.Value}\" (Index: {match.Index}, Length: {match.Length})");
                }
                
                text.AppendLine();
            }

            await JS.InvokeVoidAsync("downloadFile", "matches.txt", text.ToString(), "text/plain");
            Message = "✓ Exported matches as Text";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Export Text error: {ex.Message}");
            Message = "Error exporting Text ☠";
        }
    }

    private static string EscapeCsv(string value)
    {
        if (string.IsNullOrEmpty(value))
            return string.Empty;
        
        return value.Replace("\"", "\"\"");
    }
}

