@using System.Text.RegularExpressions
@using Blazored.LocalStorage
@inject BlazorWasmRegex.Shared.Interfaces.IRegexService regexService
@inject BlazorWasmRegex.Shared.Interfaces.IHtmlHelperService htmlHelperService
@inject ILocalStorageService LocalStorage

<p>
    <label>Regex:</label>
    <input class="form-control" @bind="RegexText" />
</p>
<p>
    <label>Options:</label>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" @bind="IgnoreCase" id="ignoreCase">
        <label class="form-check-label" for="ignoreCase">Ignore Case</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" @bind="Multiline" id="multiline">
        <label class="form-check-label" for="multiline">Multiline</label>
    </div>
    <div class="form-check form-check-inline">
        <input class="form-check-input" type="checkbox" @bind="Singleline" id="singleline">
        <label class="form-check-label" for="singleline">Singleline</label>
    </div>
</p>
<p>
    <label>Tests:</label>
    <textarea class="form-control" @bind="Tests" rows="10"></textarea>
</p>
<p>
    <div class="hr-flex-container">
        <div>
            <BSButton Color="BSColor.Primary" OnClick="@Test_Click"><span class="oi oi-beaker" aria-hidden="true">&nbsp;</span>Test</BSButton>
        </div>
        <div class="space-out">
            <span class="oi oi-terminal" aria-hidden="true">&nbsp;</span>@((MarkupString)Message)
        </div>
    </div>
</p>
<p>
    <BSTabGroup>
        <BSTabList>
            <BSTab>
                <BSTabLabel>Matches</BSTabLabel>
                <BSTabContent>
                    <ul class="list-group">
                        @foreach (var m in MatchedStrings)
                        {
                            <li class="list-group-item">@((MarkupString)m)</li>
                        }
                    </ul>
                </BSTabContent>
            </BSTab>
            <BSTab>
                <BSTabLabel>Split list</BSTabLabel>
                <BSTabContent>
                    <ul class="list-group">
                        @foreach (var m in SplitList)
                        {
                            <li class="list-group-item">@((MarkupString)m)</li>
                        }
                    </ul>
                </BSTabContent>
            </BSTab>
            <BSTab>
                <BSTabLabel>Table</BSTabLabel>
                <BSTabContent>
                    <ul class="list-group">
                        @foreach (var m in NotEmptyMatches)
                        {
                            <li class="list-group-item">
                                <strong>@m.Key</strong>
                            </li>
                            @foreach (Match match in m.Value)
                            {
                                <li class="list-group-item">
                                    <div class="hr-flex-container">
                                        <span class="space-out">
                                            Index: @match.Index
                                        </span>
                                        <span class="space-out">
                                            Length: @match.Length
                                        </span>
                                        <span class="space-out">
                                            Value: @match.Value
                                        </span>
                                    </div>
                                </li>
                            }
                        }
                    </ul>
                </BSTabContent>
            </BSTab>
        </BSTabList>
        <BSTabSelectedContent />
    </BSTabGroup>
</p>

@code {
    const string REGEX_SESSION_STORAGE_KEY = nameof(REGEX_SESSION_STORAGE_KEY);
    const string TESTS_SESSION_STORAGE_KEY = nameof(TESTS_SESSION_STORAGE_KEY);
    private static readonly TimeSpan RegexTimeout = TimeSpan.FromSeconds(2);

    protected string Tests { get; set; }
    protected string RegexText { get; set; }
    protected bool IgnoreCase { get; set; }
    protected bool Multiline { get; set; }
    protected bool Singleline { get; set; }
    protected IEnumerable<string> MatchedStrings { get; set; } = new List<string>();
    protected IEnumerable<string> SplitList { get; set; } = new List<string>();
    protected IEnumerable<KeyValuePair<string, MatchCollection>> NotEmptyMatches { get; set; } = new Dictionary<string, MatchCollection>();
    protected string Message { get; set; }

    private Regex testRegex;
    private string prevRegexConfig;

    protected override async Task OnInitializedAsync()
    {
        RegexText = await LocalStorage.GetItemAsync<string>(REGEX_SESSION_STORAGE_KEY) ?? string.Empty;
        Tests = await LocalStorage.GetItemAsync<string>(TESTS_SESSION_STORAGE_KEY) ?? string.Empty;
        var savedOptions = await LocalStorage.GetItemAsync<string>("REGEX_OPTIONS");
        if (!string.IsNullOrEmpty(savedOptions))
        {
            // Format: "{RegexText}|{IgnoreCase}|{Multiline}|{Singleline}"
            var parts = savedOptions.Split('|');
            if (parts.Length >= 4)
            {
                // We do not override RegexText here; it is loaded separately above.
                bool.TryParse(parts[^3], out var ignoreCase);
                bool.TryParse(parts[^2], out var multiline);
                bool.TryParse(parts[^1], out var singleline);
                IgnoreCase = ignoreCase;
                Multiline = multiline;
                Singleline = singleline;
            }
        }
    }

    protected async Task Test_Click(object e)
    {
        if (string.IsNullOrEmpty(RegexText))
            return;

        var currentConfig = $"{RegexText}|{IgnoreCase}|{Multiline}|{Singleline}";
        if (prevRegexConfig != currentConfig)
        {
            try
            {
                Console.WriteLine("Changing RegEx");
                var options = RegexOptions.Compiled;
                if (IgnoreCase) options |= RegexOptions.IgnoreCase;
                if (Multiline) options |= RegexOptions.Multiline;
                if (Singleline) options |= RegexOptions.Singleline;
                
                testRegex = new Regex(RegexText, options, RegexTimeout);
                prevRegexConfig = currentConfig;

                await LocalStorage.SetItemAsync(REGEX_SESSION_STORAGE_KEY, RegexText);
                await LocalStorage.SetItemAsync("REGEX_OPTIONS", currentConfig);
            }
            catch (RegexParseException regexParseEx)
            {
                Console.WriteLine($"Failed to parse a RegEx: {regexParseEx.Message}; {regexParseEx.Error}; {regexParseEx.Offset}");
                Message = $"Failed to parse an expression 😒: <b>{regexParseEx.Error}</b> at pos <b>{regexParseEx.Offset}</b>.";
                return;
            }
            catch (ArgumentException ex)
            {
                Console.WriteLine($"Failed to parse a RegEx: <b>{ex.Message}</b>; {ex.GetType().Name}");
                Message = "Failed to parse an expression 😒";
                return;
            }
        }


        try
        {
            var tests = Tests?
                .Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
                .Distinct();

            var (elapsedMilliseconds, matches) = regexService.GetMatches(tests, testRegex);

            NotEmptyMatches = matches
                .Where(kvp => kvp.Value.Count > 0)
                .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            Message = $"{NotEmptyMatches.Count()} matches in {elapsedMilliseconds} ms";

            MatchedStrings = matches
                .Select(mc => htmlHelperService.GetMarkedSpans(mc.Key, mc.Value, "mark-yellow"));

            SplitList = regexService.GetSplitList(tests, testRegex).Select(m => htmlHelperService.GetDelimeteredString(m, " <span class='oi oi-pin' aria-hidden='true'></span> "));
            await LocalStorage.SetItemAsync(TESTS_SESSION_STORAGE_KEY, Tests);
        }
        catch (RegexMatchTimeoutException timeoutEx)
        {
            Console.WriteLine($"RegEx timed out: {timeoutEx.Message}");
            Message = "⏱ Expression timed out - possible catastrophic backtracking";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Something went wrong... {ex.Message}");
            Message = "Error evaluating expression ☠";
        }
    }
}

